**Мотивация**


Простой, удобный в использовании, потокобезопасный сервер для хранения пар ключ/значение. 

Почему просто не взять базу данных N?

- Мне не нужна схема. Я хочу просто хранить бинарные данные пока постгри/майскл

- Мне не нужна скорость. Скорость всегда достигается некой ценой, которую я не хочу платить.

- Мне жалко денег на SSD - пока roksdb, badgerdb и иже с ними

- BoltDb с ростом зазмера бд начинает нещадно тормозить и насилует диск на 100% - пока

- Мне нравится Sophia Db - но я не хочу юзать CGo - до свиданья

- У меня нет вагона памяти - прощай buntDb, memcache, redis

**Slowpoke**


Почему Slowpoke? 

- я не буду писать оптимизаций под SSD - HDD - дешевле! Я не готов платить в 5 раз больше за скорость которая мне не нужна
- я не буду юзать mmap потому что у меня не вагон памяти. На типичном сайте 99% контента в базе валяются мертвым грузом. Зачем все эти оптимизации?
- я не буду изголяться c LSM Tree/Compaction и прочим бредом потому что я редко пишу в базу, и часто читаю.  Это не лог, это хранилище данных
- я уверен что без всех этих извращений - работать будет с приемлемой скоростью, но скорость не цель!

Мне не важно победит ли моя БД в бенчмарках тарантул. Мне важно чтобы она была простой и удобной.

**Архитектура**

- В памяти лежит BTree с ключами и адресами значений. 
- BTree нужен для доступа к ключам в прямом/обратном порядке и поиска по диапазону (паджинация)
- В ключе лежит имя файла с данными, ID ключа, Смещение в файле и Размер данных
- В файл данных значения просто апендятся
- При апдейте - старое значение не стирается
- Протокол сервера http/2 - потому что он бинарный, быстрый, и совмещает в себе лучшее из обоих миров (бинарный/текстовый протокол). Из коробки авторизация, двустороний обмен данными и тп
- protobuf - потому что хранить данные я буду в бинарном формате, мне плевать на то как они выглядят, я не собираюсь читать байты глазками
- grpc - потому что мне лень писать парсер протокола для клиента/сервера - пусть за меня это делает google
